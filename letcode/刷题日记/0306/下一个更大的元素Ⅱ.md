**题目：**

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:

输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
注意: 输入数组的长度不会超过 10000。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-greater-element-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



**自己解：**

```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        out = []
        n = len(nums)
        if n>0:
            max_num = max(nums)

            nums.extend(nums)
            for i in range(n):
                if nums[i]==max_num:
                    out.append(-1)
                    continue
                for j in range(i+1, i+n):
                    if nums[j] > nums[i]:
                        out.append(nums[j])
                        break
            return out
        return out
```

执行用时：2904 ms, 在所有 Python3 提交中击败了10.63%的用户

内存消耗：16.3 MB, 在所有 Python3 提交中击败了54.67%的用户



**其他解：**

解题思路
今天题目的两个重点：

如何求下一个更大的元素
如何实现循环数组
1. 如何求下一个更大的元素
本题如果暴力求解，对于每个元素都向后去寻找比它更大的元素，那么时间复杂度 O(N^2)O(N 
2
 ) 会超时。必须想办法优化。

我们注意到，暴力解法中，如果数组的前半部分是单调不增的，那么会有很大的计算资源的浪费。比如说 [6,5,4,3,8]，对于前面的 [6,5,4,3] 等数字都需要向后遍历，当寻找到元素 8 时才找到了比自己大的元素；而如果已知元素 6 向后找到元素 8 才找到了比自己的大的数字，那么对于元素 [5,4,3] 来说，它们都比元素 6 更小，所以比它们更大的元素一定是元素 8，不需要单独遍历对 [5,4,3] 向后遍历一次！

根据上面的分析可知，可以遍历一次数组，如果元素是单调递减的（则他们的「下一个更大元素」相同），我们就把这些元素保存，直到找到一个较大的元素；把该较大元素逐一跟保存了的元素比较，如果该元素更大，那么它就是前面元素的「下一个更大元素」。

在实现上，我们可以使用「单调栈」来实现，单调栈是说栈里面的元素从栈底到栈顶是单调递增或者单调递减的（类似于汉诺塔）。

本题应该用个「单调递减栈」来实现。

建立「单调递减栈」，并对原数组遍历一次：

如果栈为空，则把当前元素放入栈内；
如果栈不为空，则需要判断当前元素和栈顶元素的大小：
如果当前元素比栈顶元素大：说明当前元素是前面一些元素的「下一个更大元素」，则逐个弹出栈顶元素，直到当前元素比栈顶元素小为止。
如果当前元素比栈顶元素小：说明当前元素的「下一个更大元素」与栈顶元素相同，则把当前元素入栈。

2. 如何实现循环数组
题目说给出的数组是循环数组，何为循环数组？就是说数组的最后一个元素下一个元素是数组的第一个元素，形状类似于「环」。

一种实现方式是，把数组复制一份到数组末尾，这样虽然不是严格的循环数组，但是对于本题已经足够了，因为本题对数组最多遍历两次。
另一个常见的实现方式是，使用取模运算 %可以把下标 ii 映射到数组 numsnums 长度的 0 - N0−N 内。
代码
栈里面需要保存元素在数组中的下标，而不是具体的数字。因为需要根据下标修改结果数组 res。

```python
class Solution(object):
    def nextGreaterElements(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        N = len(nums)
        res = [-1] * N
        stack = []
        for i in range(N * 2):
            while stack and nums[stack[-1]] < nums[i % N]:
                res[stack.pop()] = nums[i % N]
            stack.append(i % N)
        return res
```

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/next-greater-element-ii/solution/dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

执行用时：288 ms, 在所有 Python3 提交中击败了23.13%的用户

内存消耗：16.3 MB, 在所有 Python3 提交中击败了48.34%的用户

- 实现循环数组的两种方法：`数组拼接` 或者`for i in range(2*N):    i%N`，推荐后者
- 单调递减栈  求下一个更大的元素

