# 题目：

颠倒给定的 32 位无符号整数的二进制位。

 

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。

- 在 Java 中，编译器使用`二进制补码记`法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数` -3`，输出表示有符号整数 `-1073741825`。

进阶:
如果多次调用这个函数，你将如何优化你的算法？

**示例 1：**

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
**示例** 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
示例 1：

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。


提示：

输入是一个长度为 32 的二进制字符串

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。转载请联系官方授权，非商业转载请注明出处。





# 自己解：



```
class Solution:
    def reverseBits(self, n: int) -> int:
        b = bin(n).lstrip('0b')
        c = len(b)
        if c<32:
            another = '0'*(32-c)
            b = another + b
        return int(b[::-1], 2)
```

| 44 ms | 14.6 MB |
| ----- | ------- |
|       |         |

# 循环：

这是最容易想到的方法了，每次把 `res` 左移，把 n 的二进制末尾数字，拼接到结果 `res` 的末尾。然后把 n 右移。

举一个 8 位的二进制进行说明：

| i    | n        | res      |
| ---- | -------- | -------- |
| -    | 11001001 | -        |
| 0    | 1100100  | 1        |
| 1    | 110010   | 10       |
| 2    | 11001    | 100      |
| 3    | 1100     | 1001     |
| 4    | 110      | 10010    |
| 5    | 11       | 100100   |
| 6    | 1        | 1001001  |
| 8    | -        | 10010011 |

i	n	res
-	11001001	-
0	1100100	1
1	110010	10
2	11001	100
3	1100	1001
4	110	10010
5	11	100100
6	1	1001001
8	-	10010011
代码如下：

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/reverse-bits/solution/fu-xue-ming-zhu-xun-huan-yu-fen-zhi-jie-hoakf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



```python
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        res = 0
        for i in range(32):
            res = (res << 1) | (n & 1)
            n >>= 1
        return res
```



- `n&1`表示取n的末位二进制数！
- `res = (res<<1) | (n & 1)`表示将n的最后一位加到res的最后一位中



# 分而治之

有另外一种不使用循环的做法，类似于**归并排序**。

其思想是分而治之，把数字分为两半，然后交换这两半的顺序；然后把前后两个半段都再分成两半，交换内部顺序……直至最后交换顺序的时候，交换的数字只有 1 位。

以一个 8 位的二进制数字为例：

![190.001.jpeg](https://pic.leetcode-cn.com/1616982968-vXsJSf-190.001.jpeg)

```python
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        n = (n >> 16) | (n << 16)
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8)
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4)
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)
        return n
```

