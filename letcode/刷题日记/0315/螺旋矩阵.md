给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**提示：**

- `m == matrix.length`

- `n == matrix[i].length`

- `1 <= m, n <= 10`

- `-100 <= matrix[i][j] <= 100`



**自己解：**没思路



**其他解：**

题意是要我们螺旋向内遍历矩阵，力扣上类似地按照一定规则打印矩阵的题目有好几个。我觉得需要考虑以下几个问题：

**1.起始位置**
**2.移动方向**
**3.边界**
**4.结束条件**

今天这个题目只要把上面几个问题想清楚了，起始不难。

**1.起始位置**
螺旋矩阵的遍历起点是矩阵的左上角，也就是` (0, 0)` 位置。

**2.移动方向**
起始位置的下一个移动方向是向右。在遍历的过程中，移动方向是固定的：

`右 → ，下↓，左←，上↑`

移动方向是按照上面的顺序循环进行的。每次当移动到了**边界**，才会更改方向。但边界并不是固定的，请看下面分析。

**3.边界**
本题的边界是最大的难点，因为是随着遍历的过程而变化的。螺旋遍历的时候，已经遍历的数字不能再次遍历，所以边界会越来越小。

规则是：**如果当前行（列）遍历结束之后，就需要把这一行（列）的边界向内移动一格。**

以下面的图为例， `up, down, left, right` 分别表示四个方向的边界，初始时分别指向矩阵的四个边界。如果我们把第一行遍历结束（遍历到了右边界），此时需要修改新的移动方向为**向下**、并且把上边界 `up` 下移一格，即从 `旧 up` 位置移动到 `新 up` 位置。

![54.001.jpeg](https://pic.leetcode-cn.com/1615772734-dyqGcJ-54.001.jpeg)

当绕了一圈后，从下向上走到 新`up` 边界的时候，此时需要修改新的移动方向为**向右**、并且把左边界 `left` 下移一格，即从 `旧 left` 位置移动到 `新 left` 位置。

![54.002.jpeg](https://pic.leetcode-cn.com/1615772827-NtyLsa-54.002.jpeg)

由此可见，根据维护的四个方向的边界，就知道什么时候更改移动方向了。

## 4. 结束条件

螺旋遍历的结束条件是所有的位置都被遍历到。

代码
下面的代码不难：

up, down, left, right 分别表示四个方向的边界。

x, y 表示当前位置。

dirs 分别表示移动方向是 右、下、左、上 。

cur_d 表示当前的移动方向的下标，dirs[cur_d] 就是下一个方向需要怎么修改 x, y。

cur_d == 0 and y == right 表示当前的移动方向是向右，并且到达了右边界，此时将移动方向更改为向下，并且上边界 up 向下移动一格。

结束条件是结果数组 res 的元素个数能与 matrix 中的元素个数。

```python
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if not matrix or not matrix[0]: return []
        M, N = len(matrix), len(matrix[0])
        left, right, up, down = 0, N - 1, 0, M - 1
        res = []
        x, y = 0, 0
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        cur_d = 0
        while len(res) != M * N:
            res.append(matrix[x][y])
            if cur_d == 0 and y == right:
                cur_d += 1
                up += 1
            elif cur_d == 1 and x == down:
                cur_d += 1
                right -= 1
            elif cur_d == 2 and y == left:
                cur_d += 1
                down -= 1
            elif cur_d == 3 and x == up:
                cur_d += 1
                left += 1
            cur_d %= 4
            x += dirs[cur_d][0]
            y += dirs[cur_d][1]
        return res
```

时间复杂度：O(M * N)O(M∗N)
空间复杂度：O(M * N)O(M∗N)，如果不把结果计算在内，那么空间复杂度为 O(1)O(1)
刷题心得
这种遍历的问题，本身其实不难，容易出错的地方在于移动方向、边界等处理。细节是魔鬼，刷题经验多了，对细节的处理也会更好一些。